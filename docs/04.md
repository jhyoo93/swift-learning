# Swift: final class, inout 매개변수, Error 처리

---  

## 1) final class

### 1.1 정의
- final 키워드를 클래스 앞에 붙이면 상속이 불가능한 클래스가 된다.
즉, 해당클래스를 다른 클래스가 상속(extends) 할 수 없다.

```swift

final class Animal {
    var name: String
    init(name: String) {
        self.name = name
    }
    
    func makeSound() {
        print("소리를 낸다")
    }
}

// Animal은 final이라 상속 불가
// class Dog: Animal { }

```

---

### 1.2 사용 이유
- 의도치 않은 상속을 막아 클래스 안정성을 보장.
- 컴파일러가 동적 디스패치(dynamic dispatch) 대신 정적 디스패치(static dispatch)를 사용하므로 실행 속도가 향상됨.
- “이 클래스는 상속하지 말고 그대로 사용해라”라는 개발자의 의도가 드러남.

---

## 2) inout 매개변수

### 2.1 정의
- 함수의 매개변수는 기본적으로 값 복사가 이루어진다 (Value Type)
- inout 키워드를 붙이면, 함수 안에서 해당 매개변수를 참조(주소) 기반으로 수정할 수 있다.
- 즉, 함수가 끝나도 값이 원본 변수에 반영된다.

```swift

func addTen(to number: inout Int) {
    number += 10
}

var value = 5
addTen(to: &value)   // & 붙여서 전달해야 함
print(value)         // 15

```
- inout 매개변수는 함수 호출 시 &기호를 붙여서 전달해야 한다.
- 함수 내부에서는 값 복사가 아닌 참조를 통해 직접 수정된다.

### 2.2 주의사항
- 상수(let) 불가
- inout 매개변수에는 기본값(default value)을 줄 수 없다.
- 옵셔널 바인딩 불가

---

## 3) Error

Swift의 에러 처리는 throw, try, do-catch 3단계로 이루어진다.

### 3.1 throw

- 에러 발생 시 사용.
- Error 프로토콜을 채택한 타입만 던질 수 있다.

```swift

enum MyError: Error { case wrong }
throw MyError.wrong

```

---

### 3.2 try
- throws 함수 실행 시 반드시 붙여야 함.
- try? → 실패 시 nil 반환
- try! → 실패 시 런타임 크래시

---

### 3.3 do-catch
- do 블록에서 try 실행
- 에러 발생 시 catch 블록으로 이동해 처리

```swift

do {
    try riskyFunction()
} catch {
    print("에러 발생: \(error)")
}

```

---

## 4) 요약

- **final class**: 클래스 상속 불가, 안정성 보장, 성능 최적화(정적 디스패치), 잘못 상속 시 컴파일 에러
- **inout 매개변수**: 원본 변수 참조 전달, 함수 종료 후에도 값 반영, & 기호 필요, 상수/리터럴/기본값 불가
- **Error 처리**: throw(에러 발생), try(에러 가능 코드 실행, try?/try! 변형 있음), do-catch(에러 잡아 처리)
